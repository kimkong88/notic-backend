model Subscription {
  id                    String             @id @default(uuid())
  userId                String
  user                  User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  billingProvider       String             // e.g. lemon_squeezy, stripe
  billingCustomerId     String?
  billingSubscriptionId String?
  status                SubscriptionStatus
  expiredAt             DateTime?         // single "access ends at" â€“ from provider (period end, trial end); has access = expiredAt == null || now < expiredAt
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  @@index([userId])
  @@index([billingSubscriptionId])
}

enum SubscriptionStatus {
  active   // paid, current
  trial    // in trial; set expiredAt = trial end from provider
  beta     // beta access, no payment (expiredAt null or far future)
  canceled // user canceled; access until expiredAt (set from period end)
  past_due // payment failed
  expired  // kept for DB compat; prefer expiredAt for "over" (no scheduler needed)
}
